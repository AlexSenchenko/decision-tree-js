<html>

<script src="decision-tree.js"></script>

<style>
canvas {
    border: 1px solid #ccc;
    margin: 30px;
}

select {
    margin: 30px;
}

/*
 Transforming nested lists to pretty tree
 
 <div class="tree">
    <ul>
        <li>
            <ul>
            ...
            </ul>
        </li>
        ...
    </ul>
 </div>
 
Source: http://thecodeplayer.com/walkthrough/css3-family-tree

TODO: http://stackoverflow.com/questions/1695115/how-do-i-draw-the-lines-of-a-family-tree-using-html-css
*/

* {margin: 0; padding: 0;}

.tree ul {
	padding-top: 20px; position: relative;
	
	transition: all 0.5s;
	-webkit-transition: all 0.5s;
	-moz-transition: all 0.5s;
}

.tree li {
	float: left; text-align: center;
	list-style-type: none;
	position: relative;
	padding: 20px 5px 0 5px;
	
	transition: all 0.5s;
	-webkit-transition: all 0.5s;
	-moz-transition: all 0.5s;
}

/*We will use ::before and ::after to draw the connectors*/

.tree li::before, .tree li::after{
	content: '';
	position: absolute; top: 0; right: 50%;
	border-top: 1px solid #ccc;
	width: 50%; height: 20px;
}
.tree li::after{
	right: auto; left: 50%;
	border-left: 1px solid #ccc;
}

/*We need to remove left-right connectors from elements without
 any siblings*/
.tree li:only-child::after, .tree li:only-child::before {
	display: none;
}

/*Remove space from the top of single children*/
.tree li:only-child{ padding-top: 0;}

/*Remove left connector from first child and
 right connector from last child*/
.tree li:first-child::before, .tree li:last-child::after{
	border: 0 none;
}
/*Adding back the vertical connector to the last nodes*/
.tree li:last-child::before{
	border-right: 1px solid #ccc;
	border-radius: 0 5px 0 0;
	-webkit-border-radius: 0 5px 0 0;
	-moz-border-radius: 0 5px 0 0;
}
.tree li:first-child::after{
	border-radius: 5px 0 0 0;
	-webkit-border-radius: 5px 0 0 0;
	-moz-border-radius: 5px 0 0 0;
}

/*Time to add downward connectors from parents*/
.tree ul ul::before{
	content: '';
	position: absolute; top: 0; left: 50%;
	border-left: 1px solid #ccc;
	width: 0; height: 20px;
}

.tree li a{
	border: 1px solid #ccc;
	padding: 5px 10px;
	text-decoration: none;
	color: #666;
	font-family: arial, verdana, tahoma;
	font-size: 11px;
	display: inline-block;
	
	border-radius: 5px;
	-webkit-border-radius: 5px;
	-moz-border-radius: 5px;
	
	transition: all 0.5s;
	-webkit-transition: all 0.5s;
	-moz-transition: all 0.5s;
}

/*Time for some hover effects*/
/*We will apply the hover effect the the lineage of the element also*/
.tree li a:hover, .tree li a:hover+ul li a {
	background: #c8e4f8; color: #000; border: 1px solid #94a0b4;
}
/*Connector styles on hover*/
.tree li a:hover+ul li::after,
.tree li a:hover+ul li::before,
.tree li a:hover+ul::before,
.tree li a:hover+ul ul::before{
	border-color:  #94a0b4;
}

/*Thats all. I hope you enjoyed it.
 Thanks :)*/

</style>

<script>
function init() {
    
    function hexToRgb(hex) {
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex,
                          function(m, r, g, b) {
                            return r + r + g + g + b + b;
                          });
                          
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
                            r: parseInt(result[1], 16),
                            g: parseInt(result[2], 16),
                            b: parseInt(result[3], 16)
                        } : null;
    }
    
    var canv = document.getElementById('myCanvas'),
        colorSelect = document.getElementById('colorSelect'),
        clearBtn = document.getElementById('clearBtn'),
        treeBlock = document.getElementById('treeDiv'),
        context = canv.getContext('2d'),
        elements = [],
        color = colorSelect.options[colorSelect.selectedIndex].value,
        radius = 3,
        points = [],
        tree = null;
        
    // Default set of predicates is: '==', '>=' and '<='
    // But each point have only continuous attributes: x, y
    // So, we will use only '>=' and '<=' predicates
    delete predicates['=='];
    
    function drawCircle(x, y, hexColor) {
        context.beginPath();
        context.arc(x, y, radius, 0, 2 * Math.PI, false);

        var c = hexToRgb(hexColor)
        context.fillStyle = 'rgb(' + c.r + ',' + c.g + ',' + c.b + ')';
        
        context.fill();
        context.closePath();
        context.stroke();
    }
    
    function displayTreePredictions() {
        context.clearRect ( 0 , 0 , canv.width , canv.height );
        
        for(var x = 0; x < canv.width; x++) {
            for(var y = 0; y < canv.height; y++) {

                var predictedHexColor = predict(tree, {x : x, y : y});
                
                // put pixel
                var c = hexToRgb(predictedHexColor);
                context.fillStyle = 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',' + 0.5 + ')';
                context.fillRect( x, y, 1, 1 );
            }
        }
    }
    
    function displayPoints() {
        for(var p in points) {
            drawCircle(points[p].x, points[p].y, points[p].color);
        }
    }
    
    function treeToHtml(tree) {
        if (tree.category) {
            return '<ul><li><a href="#" style="background-color:' + tree.category + '">Color</a></li></ul>';
        }
        
        return '<ul><li>' +
            '<a href="#">' + tree.attribute + ' ' + tree.predicate + ' ' + tree.pivot + '</a>' +
            '<ul>' +
                '<li> <a href="#">true</a>' + treeToHtml(tree.match) + '</li>' +
                '<li> <a href="#">false</a>' + treeToHtml(tree.notMatch) + '</li>' +
            '</ul>' +
            '</li></ul>';
    }
    
    var addingPoints = false;
    canv.addEventListener('mousedown',
                          function(e) {
                            e.preventDefault();
                            addingPoints = true;
                          },
                          false);
    
    canv.addEventListener('mouseup',
                          function(e) {
                            if(points.length == 0) return;
                          
                            addingPoints = false;
                          
                            var threshold = points.length / 100;
                            threshold = (threshold > 1) ? threshold : 1;
                          
                            tree = buildTree(points, threshold, 'color');
                          
                            displayTreePredictions();
                            displayPoints();
                            treeBlock.width = 5000;
                            treeBlock.innerHTML = treeToHtml(tree);
                          },
                          false);

    canv.addEventListener('mouseout',
                          function(e) {
                            if(points.length == 0) return;
                          
                            addingPoints = false;
                          
                            var threshold = points.length / 100;
                            threshold = (threshold > 1) ? threshold : 1;
                          
                            tree = buildTree(points, threshold, 'color');
                          
                            displayTreePredictions();
                            displayPoints();
                            treeBlock.innerHTML = treeToHtml(tree);
                          },
                          false);
    
    canv.addEventListener('mousemove',
                          function(e) {
                            if(addingPoints) {
                                var x = e.offsetX ? e.offsetX : (e.layerX - canv.offsetLeft);
                                var y = e.offsetY ? e.offsetY : (e.layerY - canv.offsetTop );
                                drawCircle(x, y, color);
                                points.push({x : x, y : y, color : color});
                            }
                          },
                          false);

    colorSelect.addEventListener('change',
                                 function(event) {
                                    var selected = colorSelect.selectedIndex;
                                    color = colorSelect.options[selected].value;
                                 },
                                 false);

    clearBtn.addEventListener('click',
                              function(event) {
                                context.clearRect ( 0 , 0 , canv.width , canv.height );
                                points = [];
                                treeBlock.innerHTML = '';
                              },
                              false);
}
</script>

<body onload="init()">
    
	<select id="colorSelect">
		<option value="#33CCFF">Blue</option>
		<option value="#FF6600">Red</option>
        <option value="#009933">Green</option>
	</select>
    
	<button id="clearBtn">clear</button>
    
	<br/>
    
	<canvas id="myCanvas" width="200" height="200"></canvas>
    
    <br/>
    
    <div class="tree" id="treeDiv"></div>
</body>
</html>
