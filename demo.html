<html>

<style>
canvas {
    border: 1px solid #ccc;
    margin: 30px;
}

.color-select {
    margin: 30px;
    width : 30px;
    height : 30px;
    display:inline-block;
}

/*
 Transforming nested lists to pretty tree
 
 <div class="tree">
    <ul>
        <li>
            <ul>
            ...
            </ul>
        </li>
        ...
    </ul>
 </div>
 
Source: http://thecodeplayer.com/walkthrough/css3-family-tree

Some other advices about displaying trees: http://stackoverflow.com/questions/1695115/how-do-i-draw-the-lines-of-a-family-tree-using-html-css
*/

* {
    margin: 0;
    padding: 0;
}

.tree ul {
	padding-top: 20px;
    position: relative;
	
	transition: all 0.5s;
	-webkit-transition: all 0.5s;
	-moz-transition: all 0.5s;
}

.tree li {
    white-space: nowrap;
	float: left;
    text-align: center;
	list-style-type: none;
	position: relative;
	padding: 20px 5px 0 5px;
	
	transition: all 0.5s;
	-webkit-transition: all 0.5s;
	-moz-transition: all 0.5s;
}

/*We will use ::before and ::after to draw the connectors*/

.tree li::before, .tree li::after{
	content: '';
	position: absolute;
    top: 0;
    right: 50%;
	border-top: 1px solid #ccc;
	width: 50%;
    height: 20px;
}
.tree li::after{
	right: auto;
    left: 50%;
	border-left: 1px solid #ccc;
}

/*We need to remove left-right connectors from elements without
 any siblings*/
.tree li:only-child::after, .tree li:only-child::before {
	display: none;
}

/*Remove space from the top of single children*/
.tree li:only-child{
    padding-top: 0;
}

/*Remove left connector from first child and
 right connector from last child*/
.tree li:first-child::before, .tree li:last-child::after{
	border: 0 none;
}
/*Adding back the vertical connector to the last nodes*/
.tree li:last-child::before{
	border-right: 1px solid #ccc;
	border-radius: 0 5px 0 0;
	-webkit-border-radius: 0 5px 0 0;
	-moz-border-radius: 0 5px 0 0;
}
.tree li:first-child::after{
	border-radius: 5px 0 0 0;
	-webkit-border-radius: 5px 0 0 0;
	-moz-border-radius: 5px 0 0 0;
}

/*Time to add downward connectors from parents*/
.tree ul ul::before{
	content: '';
	position: absolute;
    top: 0;
    left: 50%;
	border-left: 1px solid #ccc;
	width: 0;
    height: 20px;
}

.tree li a{
	border: 1px solid #ccc;
	padding: 5px 10px;
	text-decoration: none;
	color: #666;
	font-family: arial, verdana, tahoma;
	font-size: 11px;
	display: inline-block;
	
	border-radius: 5px;
	-webkit-border-radius: 5px;
	-moz-border-radius: 5px;
	
	transition: all 0.5s;
	-webkit-transition: all 0.5s;
	-moz-transition: all 0.5s;
}

/*Time for some hover effects*/
/*We will apply the hover effect the the lineage of the element also*/
.tree li a:hover, .tree li a:hover+ul li a {
	background: #c8e4f8;
    color: #000;
    border: 1px solid #94a0b4;
}
/*Connector styles on hover*/
.tree li a:hover+ul li::after,
.tree li a:hover+ul li::before,
.tree li a:hover+ul::before,
.tree li a:hover+ul ul::before{
	border-color:  #94a0b4;
}

/*Thats all. I hope you enjoyed it.
 Thanks :)*/
</style>

<script type="text/javascript" src="decision-tree.js"></script>

<script type="text/javascript">

/*
 * Taken from: http://stackoverflow.com/a/5624139/653511
 */
function hexToRgb(hex) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function(m, r, g, b) {
        return r + r + g + g + b + b;
    });
                      
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}

function drawCircle(context, x, y, radius, hexColor) {
    context.beginPath();
    context.arc(x, y, radius, 0, 2 * Math.PI, false);
    
    var c = hexToRgb(hexColor)
    context.fillStyle = 'rgb(' + c.r + ',' + c.g + ',' + c.b + ')';
    
    context.fill();
    context.closePath();
    context.stroke();
}

function putPixel(imageData, width, x, y, hexColor, alpha) {
    var c = hexToRgb(hexColor);
    var indx = (y * width + x) * 4;
    
    var currAlpha = imageData.data[indx + 3];
    
    imageData.data[indx + 0] = (c.r * alpha + imageData.data[indx + 0] * currAlpha) / (alpha + currAlpha);
    imageData.data[indx + 1] = (c.g * alpha + imageData.data[indx + 1] * currAlpha) / (alpha + currAlpha);
    imageData.data[indx + 2] = (c.b * alpha + imageData.data[indx + 2] * currAlpha) / (alpha + currAlpha);
    imageData.data[indx + 3] = alpha + currAlpha;
}

function init() {
    
    var canv = document.getElementById('myCanvas');
    var clearBtn = document.getElementById('clearBtn');
    var treeBlock = document.getElementById('treeDiv');
    var context = canv.getContext('2d');
    
    var colorSelectElements = document.getElementsByClassName('color-select');
    for(var i = 0; i < colorSelectElements.length; i++) {
        colorSelectElements[i].style.backgroundColor = colorSelectElements[i].getAttribute('label');
    }

    var color = colorSelectElements[0].getAttribute('label');;
    var POINT_RADIUS = 3;
    var points = [];
    var tree = null;
    var forest = null;
    var TREES_NUMBER = 7;
    
    function displayTreePredictions() {
        context.clearRect ( 0 , 0 , canv.width , canv.height );
        
        var imageData = context.getImageData(0, 0, canv.width, canv.height);
        
        for(var x = 0; x < canv.width; x++) {
            for(var y = 0; y < canv.height; y++) {
                
                /*
                var predictedHexColor = predict(tree, {x : x, y : y});
                putPixel(imageData, canv.width, x, y, predictedHexColor, 128);
                 */
                
                
                var prediction = forest.predict({x : x, y : y});
                var sum = 0;
                for(var hexColor in prediction) {
                    sum += prediction[hexColor];
                }
                
                for(var hexColor in prediction) {
                    putPixel(imageData, canv.width, x, y, hexColor, prediction[hexColor] * 128 / sum);
                }
            }
        }
        
        context.putImageData(imageData, 0, 0);
    }
    
    function displayPoints() {
        for(var p in points) {
            drawCircle(context, points[p].x, points[p].y, POINT_RADIUS, points[p].color);
        }
    }
    
    function treeToHtml(tree) {
        if (tree.category) {
            return '<ul><li><a href="#" style="background-color:' + tree.category + '">&nbsp;</a></li></ul>';
        }
        
        return '<ul><li>' +
            '<a href="#">' + tree.attribute + ' ' + tree.predicate + ' ' + tree.pivot + '</a>' +
            '<ul>' +
                '<li> <a href="#">true</a>' + treeToHtml(tree.match) + '</li>' +
                '<li> <a href="#">false</a>' + treeToHtml(tree.notMatch) + '</li>' +
            '</ul>' +
            '</li></ul>';
    }
    
    var addingPoints = false;
    canv.addEventListener('mousedown',
                          function(e) {
                            e.preventDefault();
                            addingPoints = true;
                          },
                          false);
    
    canv.addEventListener('mouseup',
                          function(e) {
                            if(!addingPoints) return;
                          
                            if(points.length == 0) return;
                          
                            addingPoints = false;
                          
                            var threshold = points.length / 100;
                            threshold = (threshold > 1) ? threshold : 1;
                            /*
                            tree = buildDecisionTree({
                                                        trainingSet : points,
                                                        minItemsCount : threshold,
                                                        categoryAttr : 'color'
                                                     });
                             */
                            forest = new dt.RandomForest({
                                                        trainingSet : points,
                                                        categoryAttr : 'color',
                                                      removeDefaultPredicates : ['==']
                                                       }, TREES_NUMBER);
                          
                            displayTreePredictions();
                            displayPoints();
                            treeBlock.width = 5000;
                          
                            //treeBlock.innerHTML = treeToHtml(tree);
                          },
                          false);

    canv.addEventListener('mouseout',
                          function(e) {
                            if(!addingPoints) return;
                          
                            if(points.length == 0) return;
                          
                            addingPoints = false;
                          
                            var threshold = points.length / 100;
                            threshold = (threshold > 1) ? threshold : 1;
                            /*
                            tree = buildDecisionTree({
                                trainingSet : points,
                                minItemsCount : threshold,
                                categoryAttr : 'color'
                            });
                             */
                          forest = new dt.RandomForest({
                                                    trainingSet : points,
                                                    categoryAttr : 'color',
                                                    removeDefaultPredicates : ['==']
                                                    }, TREES_NUMBER);
                          
                            displayTreePredictions();
                            displayPoints();
                            //treeBlock.innerHTML = treeToHtml(tree);
                          },
                          false);
    
    canv.addEventListener('mousemove',
                          function(e) {
                            if(addingPoints) {
                                var x = e.offsetX ? e.offsetX : (e.layerX - canv.offsetLeft);
                                var y = e.offsetY ? e.offsetY : (e.layerY - canv.offsetTop );
                                drawCircle(context, x, y, POINT_RADIUS, color);
                                points.push({x : x, y : y, color : color});
                            }
                          },
                          false);


    for(var i = 0; i < colorSelectElements.length; i++) {
        colorSelectElements[i].addEventListener('click',
                                                function(event) {
                                                    color = this.getAttribute('label');
                                                },
                                                false);
    }

    clearBtn.addEventListener('click',
                              function(event) {
                                context.clearRect ( 0 , 0 , canv.width , canv.height );
                                points = [];
                                treeBlock.innerHTML = '';
                              },
                              false);
}
</script>

<body onLoad="init()">
    
    <div class="color-select" label="#33CCFF">&nbsp;</div>
    <div class="color-select" label="#009933">&nbsp;</div>
    <div class="color-select" label="#FF6600">&nbsp;</div>
    
    
	<button id="clearBtn">clear</button>
    
	<br/>
    
	<canvas id="myCanvas" width="400" height="400"></canvas>
    
    <br/>
    
    <div class="tree" id="treeDiv"></div>
</body>
</html>
