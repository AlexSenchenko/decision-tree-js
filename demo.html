<html>

<script src="decision-tree.js"></script>

<style>
canvas {
    border: 1px solid #ccc;
    margin: 30px;
}

select {
    margin: 30px;
}
</style>

<script>
function init() {
    
    function hexToRgb(hex) {
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex,
                          function(m, r, g, b) {
                            return r + r + g + g + b + b;
                          });
                          
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
                            r: parseInt(result[1], 16),
                            g: parseInt(result[2], 16),
                            b: parseInt(result[3], 16)
                        } : null;
    }
    
    var canv = document.getElementById('myCanvas'),
        colorSelect = document.getElementById('colorSelect'),
        clearBtn = document.getElementById('clearBtn'),
        context = canv.getContext('2d'),
        elements = [],
        color = colorSelect.options[colorSelect.selectedIndex].value,
        radius = 3,
        points = [],
        tree = null;
        
    // Default set of predicates is: '==', '>=' and '<='
    // But each point have only continuous attributes: x, y
    // So, we will use only '>=' and '<=' predicates
    delete predicates['=='];
    
    function drawCircle(x, y, hexColor) {
        context.beginPath();
        context.arc(x, y, radius, 0, 2 * Math.PI, false);

        var c = hexToRgb(hexColor)
        context.fillStyle = 'rgb(' + c.r + ',' + c.g + ',' + c.b + ')';
        
        context.fill();
        context.closePath();
        context.stroke();
    }
    
    function displayTreePredictions() {
        context.clearRect ( 0 , 0 , canv.width , canv.height );
        
        for(var x = 0; x < canv.width; x++) {
            for(var y = 0; y < canv.height; y++) {

                var predictedHexColor = predict(tree, {x : x, y : y});
                
                // put pixel
                var c = hexToRgb(predictedHexColor);
                context.fillStyle = 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',' + 0.5 + ')';
                context.fillRect( x, y, 1, 1 );
            }
        }
    }
    
    function displayPoints() {
        for(var p in points) {
            drawCircle(points[p].x, points[p].y, points[p].color);
        }
    }
    
    var addingPoints = false;
    canv.addEventListener('mousedown',
                          function(e) {
                            e.preventDefault();
                            addingPoints = true;
                          },
                          false);
    
    canv.addEventListener('mouseup',
                          function(e) {
                            addingPoints = false;
                          
                            var threshold = points.length / 100;
                            threshold = (threshold > 1) ? threshold : 1;
                          
                            tree = buildTree(points, threshold, 'color');
                          
                            displayTreePredictions();
                            displayPoints();
                          },
                          false);

    canv.addEventListener('mouseleave',
                          function(e) {
                            addingPoints = false;
                          
                            var threshold = points.length / 100;
                            threshold = (threshold > 1) ? threshold : 1;
                          
                            tree = buildTree(points, threshold, 'color');
                          
                            displayTreePredictions();
                            displayPoints();
                          },
                          false);
    
    canv.addEventListener('mousemove',
                          function(e) {
                            if(addingPoints) {
                                var x = e.offsetX ? e.offsetX : (e.layerX - canv.offsetLeft);
                                var y = e.offsetY ? e.offsetY : (e.layerY - canv.offsetTop );
                                drawCircle(x, y, color);
                                points.push({x : x, y : y, color : color});
                            }
                          },
                          false);

    colorSelect.addEventListener('change',
                                 function(event) {
                                    var selected = colorSelect.selectedIndex;
                                    color = colorSelect.options[selected].value;
                                 },
                                 false);

    clearBtn.addEventListener('click',
                              function(event) {
                                context.clearRect ( 0 , 0 , canv.width , canv.height );
                                points = [];
                              },
                              false);
}
</script>

<body onload="init()">
    
	<select id="colorSelect">
		<option value="#33CCFF">Blue</option>
		<option value="#FF6600">Red</option>
        <option value="#009933">Green</option>
	</select>
    
	<button id="clearBtn">clear</button>
    
	<br/>
    
	<canvas id="myCanvas" width="200" height="200"></canvas>
</body>
</html>
